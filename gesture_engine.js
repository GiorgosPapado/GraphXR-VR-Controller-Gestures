import * as THREE from "../build/three.module.js";



class GestureRecognizer {
    constructor() {       
        this.class_names = ["I", "U", "INFINITY", "<", "O", "L", "e", "M","Negative"];
        this.initialized = false;
    }


    async _init() {
        if (!this.initialized) {
            this.session = await ort.InferenceSession.create("./pyrocket3.onnx");
            this.initialized = true;
        }
    }

    argMax(array) {
        return [].map.call(array, (x, i) => [x, i]).reduce((r, a) => (a[0] > r[0] ? a : r))[1];
    }

    getAxisAndAngleFromQuaternion(q) {
        const angle = 2 * Math.acos(q.w);
        let s;
        if (1 - q.w * q.w < 0.000001) {
          // test to avoid divide by zero, s is always positive due to sqrt
          // if s close to zero then direction of axis not important
          // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/
          s = 1;
        } else { 
          s = Math.sqrt(1 - q.w * q.w);
        }
        return { axis: new THREE.Vector3(q.x/s, q.y/s, q.z/s), angle };
    }

    async inference(controllerPositions, controllerOrientations, timestamps) {
        let ControllerInput = [[],[],[],[]];   // 4xT                
        let refPos = controllerPositions[0].clone();      
        let refOrient = controllerOrientations[0].clone();
        let invRefOrient = refOrient.clone();
        invRefOrient.invert();
        for (let i=0;i<controllerPositions.length;i++) {
            
            let controllerPos = controllerPositions[i].clone();
            let transPos = new THREE.Vector3();       
            transPos.subVectors(controllerPos, refPos);            
            transPos.applyQuaternion(invRefOrient);
            transPos.z *= -1.0;
            
            ControllerInput[0].push(transPos.x);
            ControllerInput[1].push(transPos.y);
            ControllerInput[2].push(transPos.z);
            ControllerInput[3].push(timestamps[i]);
        }

        await this._init();
        let GestureSequenceLength = ControllerInput[0].length;

        let Concatenate = ControllerInput[0].concat(ControllerInput[1], ControllerInput[2], ControllerInput[3]);
        const input0 = new ort.Tensor(new Float32Array(Concatenate), [1, 4, GestureSequenceLength]);
        const outputs = await this.session.run({ input: input0 });

        //consume the output
        const outputTensor = outputs["output"];
        //Converting into one dimensional array probabilities generated by ONNX model
        const probabilities = Array.from(outputTensor.data);        
        const class_id = this.argMax(probabilities);
        const class_name = this.class_names[class_id];
        return {
            "class_id": class_id,
            "class_name": class_name,            
            "confidence" : probabilities[class_id],
            "class_probabilities" : probabilities
        };
    }
}
export { GestureRecognizer };